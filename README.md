# Simon Says Game for AVR Microcontroller

Simon Says Game for AVR Microcontroller is a project developed for QUT's IFB104 "Building IT Systems" (Semester 1, 2023). In this game, the microcontroller generates a sequence of tones and digits that the player must replicate using push buttons. The game features interactive audio-visual feedback, a dynamically increasing sequence generated via an LFSR, and a state machine that governs game progression.

## Table of Contents

- [Overview](#overview)
- [Features](#features)
- [Technologies Used](#technologies-used)
- [Installation](#installation)
- [Usage](#usage)
- [Game Mechanics](#game-mechanics)
- [Code Structure](#code-structure)

## Overview

Simon Says challenges you to accurately reproduce a sequence generated by the microcontroller. The game uses a state machine to transition through multiple phases—including initialization, Simon's turn, the player's turn, and result evaluation. A Linear Feedback Shift Register (LFSR) dynamically generates the sequence, increasing its length with each successful round and raising the level of challenge.

## Features

- **Dynamic Sequence Generation:**
  - Generates a pseudo-random sequence using an LFSR that grows in length with each successful round.
  
- **State Machine Control:**
  - Manages game states including initialization (INIT), Simon’s turn (SIMONS_TURN), player’s turn (PLAYERS_TURN), and result evaluation (RESULT).

- **Audio-Visual Feedback:**
  - Uses a buzzer to play tones and a display to show digits and game messages (e.g., victory, defeat, and score).

- **Interactive Gameplay:**
  - Captures push button inputs to allow the player to replicate Simon’s sequence.

- **Real-Time Timing and Interrupts:**
  - Employs timers and interrupts for precise control of tone durations, display updates, and input debouncing.

## Technologies Used

- **C** – The primary programming language.
- **AVR-GCC** – Compiler for AVR microcontrollers.
- **AVR-libc** – Standard C library for AVR development.
- **AVR Microcontrollers** – (e.g., ATtiny85 or a similar device).
- **Hardware Peripherals** – Buzzer, display, push buttons, ADC, and timers.

## Installation

### Using the Command Line

1. **Clone the Repository:**

   ```bash
   git clone https://github.com/yourusername/simon-says-avr.git
   cd simon-says-avr
   ```

2. **Compile the Project:**

   Ensure that avr-gcc, avr-libc, and avrdude are installed. Use the provided Makefile (adjust MCU and clock settings if necessary):

   ```bash
   make
   ```

   This command will generate a HEX file (e.g., simon.hex).

3. **Program the Microcontroller:**

   Use avrdude to flash the HEX file onto your AVR microcontroller. For example:

   ```bash
   avrdude -c usbtiny -p t85 -U flash:w:simon.hex:i
   ```

   Adjust the programmer (-c) and microcontroller (-p) options as needed.

## Usage

1. **Power Up and Reset:**
   - After programming, reset your AVR microcontroller to start the game.

2. **Game Start:**
   - The game initializes and transitions to Simon’s turn, where a sequence of tones and digits is played via the buzzer and display.

3. **Player Interaction:**
   - Use the push buttons to replicate the sequence shown.
   - If the sequence is correct, the game progresses with an increased sequence length.
   - If the sequence is incorrect, a defeat message is displayed and the game resets.

4. **Feedback:**
   - The buzzer provides audio feedback for each tone.
   - The display shows digits and status messages (e.g., victory, defeat, current score).

## Game Mechanics

- **State Machine:**
  - The game transitions through states such as INIT, SIMONS_TURN, PLAYERS_TURN, and RESULT, ensuring orderly game progression.

- **LFSR Sequence Generation:**
  - A Linear Feedback Shift Register is used to generate a pseudo-random sequence that increases in length each round.

- **Real-Time Timing and Control:**
  - Timers and interrupts are used to manage tone durations, display updates, and push button input debouncing.

- **Player Input Evaluation:**
  - The player's input is compared with Simon’s generated sequence to determine if the sequence has been correctly replicated.

## Code Structure

- **main.c:**
  - Contains the `main()` function and the primary state machine that manages game logic.

- **buzzer.c / buzzer.h:**
  - Functions to control the buzzer for audio output.

- **display.c / display.h:**
  - Functions to control the display for visual output.

- **timer.c / timer.h:**
  - Timer initialization and management functions for precise time tracking.

- **sequence.c / sequence.h:**
  - Implements the LFSR-based sequence generation logic.

- **uart.c / uart.h:**
  - (Optional) Functions for serial communication, useful for debugging.

- **types.h:**
  - Contains custom type definitions and enumerations for various game states.

- **initialisation.c / initialisation.h:**
  - Handles the initialization of hardware peripherals (buttons, ADC, SPI, etc.).
